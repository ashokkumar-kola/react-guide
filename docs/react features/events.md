
# EVENTS

## Synthetic Events
- Cross-browser compatibility - wrapper around the browser's native event system
- Performance - event delegation
- Consistent API 

    `bubbles`: A boolean indicating whether the event bubbles up through the DOM tree.
    `cancelable`: A boolean indicating whether the event can be canceled.
    `currentTarget`: A reference to the element that the event listener is attached to.
    `defaultPrevented`: A boolean indicating whether preventDefault() has been called on the event.
    `eventPhase`: A number indicating the current phase of the event lifecycle.
    `isTrusted`: A boolean indicating whether the event was generated by the user or by the browser.
    `nativeEvent`: A reference to the underlying native browser event.
    `target`: A reference to the element that triggered the event.
    `timeStamp`: The time at which the event was created.
    `type`: A string representing the type of event.

---

## Attaching Event Listeners

- event listeners names - camelCase
- event handler function - `onClick={handleClick}`
- `event` - const handleClick = (`event`) => { ... } - synthetic event object

---

## Common Event Types

### Mouse Events
  - `onClick`
  - `onDoubleClick`
  - `onMouseEnter`
  - `onMouseLeave`
  - `onMouseOver`
  - `onMouseOut`

### Keyboard Events
  - `onKeyDown`
  - `onKeyUp`
  - `onKeyPress`

### Form Events
  - `onChange`
  - `onSubmit`

### Other Events
  - `onFocus`
  - `onBlur`
  - `onScroll`
  - `onLoad`

---

## Working with Event Objects

### Accessing Event Properties
  - `event.target`
  - `event.target.value`

### Preventing Default Behavior
  - `event.preventDefault()`

### Stopping Event Propagation
  - `event.stopPropagation()`

---

## Passing Arguments to Event Handlers

### Using Arrow Functions
    - onClick={(event) => handleClick('My Button', event)}

### Using bind
    - onClick={handleClick.bind(this, 'My Button')}

---

## Event Handling in Class Components
- onClick={this.handleClick}

---

# COMPONENTS

## Controlled Components - React State
- How
  - State Management - `useState`
  - Event Handling - `onChange`
  - Value Binding - `value`
  - State Update - `setState`

- Advantages
  - Real-time Validation
  - Conditional Rendering
  - Data Transformation
  - Complete Control
  - Single Source of Truth

- Disadvantages
  - More Code
  - Performance Overhead

---

## Uncontrolled Components - DOM

- How
  - Create a Ref - ref - React.useRef(), React.createRef()
  - Attach the Ref - ref={inputRef}
  - Access the Value - ref.current.value

- Advantages
  - Less Code
  - Performance

- Disadvantages
  - Limited Control
  - Difficult Validation
  - Less Reusable
  - Accessing values
  - Testing

---

# FORMS

## Importance of Input Validation
- Data Integrity - accurate & reliable
- Security - SQL injection, cross-site scripting(XSS)
- User Experience
- Application Stability

## Implementing Basic Validation
```jsx
{emailError && <p className="error">{emailError}</p>}
```

## More Complex Validation Scenarios

## Validation on Form Submission
- validateForm()

## Third-Party Validation Libraries
- Formik
- Yup
- React Hook Form
- Joi

- Declarative, Schema-based, Asynchronous, Integration, Customizable 

---

## Handling Different Input Types
## Handling Multiple Inputs with a Single Handler
## Considerations for Complex Data Structures

---

## Preparing Form Data for Submission

### application/json
- JSON (JavaScript Object Notation)

const formData = {
  name: 'John Doe',
  email: 'john.doe@example.com',
  message: 'Hello, this is a test message.'
};

const jsonData = JSON.stringify(formData);
console.log(jsonData);
// Output: {"name":"John Doe","email":"john.doe@example.com","message":"Hello, this is a test message."}


### multipart/form-data


## Sending Form Data with the fetch API

- fetch - json
    const response = await fetch('/api/submit', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(formData)
    });

    const data = await response.json();


- fetch - multipart/form-data
    const response = await fetch('/api/upload', {
      method: 'POST',
      body: formData // No need to set Content-Type; the browser does it automatically
    });

    const data = await response.json();

## Parsing the Response Body

    JSON: Use response.json() to parse the JSON data.
    Text: Use response.text() to get the response as plain text.
    Blob: Use response.blob() to get the response as binary data (e.g., for downloading files).
    ArrayBuffer: Use response.arrayBuffer() for binary data that needs to be manipulated at a low level.





> React relies on detecting changes to the array reference, not just its contents.